Texture2D<float4> InputMap : register(t0);
Texture2D<float> ReductionMap : register(t0);
RWTexture2D<float> OutputMap : register(u0);

#define NumThreads 256
#define ReductionTGSize 16
groupshared float LumSamples[NumThreads];

// Calculates luminance from an RGB value
float CalcLuminance(float3 color)
{
    return dot(color, float3(0.299f, 0.587f, 0.114f));
}

//=================================================================================================
// Luminance reduction, intial pass
//=================================================================================================
[numthreads(ReductionTGSize, ReductionTGSize, 1)]
void LuminanceReductionInitialCS(in uint3 GroupID : SV_GroupID,
                                 in uint3 GroupThreadID : SV_GroupThreadID,
                                 uint ThreadIndex : SV_GroupIndex)
{
    uint2 textureSize;
    InputMap.GetDimensions(textureSize.x, textureSize.y);

    uint2 samplePos = GroupID.xy * ReductionTGSize + GroupThreadID.xy;
    samplePos = min(samplePos, textureSize - 1);

    float3 colorSample = InputMap[samplePos].xyz;

    float lumSample = max(CalcLuminance(colorSample), 0.00001f);
    float pixelLuminance = log(lumSample);

    // -- store in shared memory
    LumSamples[ThreadIndex] = pixelLuminance;
    GroupMemoryBarrierWithGroupSync();

    // -- reduce
	[unroll]
	for(uint s = NumThreads / 2; s > 0; s >>= 1)
    {
		if(ThreadIndex < s)
			LumSamples[ThreadIndex] += LumSamples[ThreadIndex + s];

		GroupMemoryBarrierWithGroupSync();
	}

    if(ThreadIndex == 0)
	{
        OutputMap[GroupID.xy] = LumSamples[0] / NumThreads;
		// OutputMap[GroupID.xy] = lumSample;
	}
}