#ifndef BLOOM_PS
#define BLOOM_PS
#include "ColoredMinimalMesh_Structs.fx"
#include "StandardTextureResources.fx"

// static const float KeyValue = 0.1150f;
static const float KeyValue = 0.2f;

float3 CalcExposedColor(float3 color, float avgLuminance, float offset, out float exposure)
{
    // Use geometric mean
    avgLuminance = max(avgLuminance, 0.001f);
	
    float linearExposure = (KeyValue / avgLuminance);
    exposure = log2(max(linearExposure, 0.0001f));
	
    exposure += offset;
    // exposure -= ExposureScale;
	
    return exp2(exposure) * color;
}

float CalcLuminance(float3 color)
{
    return dot(color, float3(0.299f, 0.587f, 0.114f));
}


float4 Bloom_PS(COLORED_MINIMAL_MESH_PS_IN pIn)
{
	float4 reds = gDiffuseMap.GatherRed(gDiffuseMapSampler, pIn.iColor);
    float4 greens = gDiffuseMap.GatherGreen(gDiffuseMapSampler, pIn.iColor);
    float4 blues = gDiffuseMap.GatherBlue(gDiffuseMapSampler, pIn.iColor);

    float3 result = 0.0f;
    float weightSum = 0.0f;

    [unroll]
    for(uint i = 0; i < 4; ++i)
    {
        float3 color = float3(reds[i], greens[i], blues[i]);

        // Apply exposure offset
        float avgLuminance = gAdditionalDiffuseMap.Load(uint3(0, 0, 0)).x;
		avgLuminance = min(10.0, max(0.3, avgLuminance));
		
        float exposure = 0;
        // result += CalcExposedColor(color, avgLuminance, BloomExposure, exposure);
        result += CalcExposedColor(color, avgLuminance, -4.0, exposure);

        //float weight = 1.0f;
		float weight = 1.0f / (1.0f + CalcLuminance(color));
        result *= weight;
        weightSum += weight;
    }

    result /= weightSum;

    return float4(result, 1.0f);
}

PS_wrapper_COLORED_MINIMAL_MESH(Bloom_PS)

#endif 