#ifndef DEFERRED_LIGHT_PASS_CLUSTERED_PS
#define DEFERRED_LIGHT_PASS_CLUSTERED_PS

#include "APIAbstraction.gpu"
#include "StandardConstants.fx"
#include "StandardTextureResources.fx"
#include "samplerhelper.fx"
#include "lighthelper.fx"
#include "ColoredMinimalMesh_Structs.fx"
#include "DeferredLightCommon.fx"

#define MAX_STEPS 300
#define MAX_INTERSECT_DIST 0.04

float getPointLightAtt(float radius, float dist) 
{
    // Soft transition
    float attenuation = pow(1.0 + (dist / radius) , -2.0) * 1.2;
    
    float cutoff = radius * 0.7;
    attenuation *= 1.0 - smoothstep(0.0, 1.0, ( (dist / cutoff) - 1.0) * 4.0 );
    attenuation = max(0.0, attenuation);
    return attenuation;
}

float3 blinn_phong(float3 n, float3 l, float3 e, 
				   float3 le, float3 la, float spec_pow, 
				   float3 kd, float3 ks, float3 ka, float att)
{
	float NoH = 0.0f;
	float NoL = dot(n, l);
	float3 diffuse = float3(0, 0, 0);
	float3 specular = float3(0, 0, 0);
	if (NoL > 0)
	{
		float3 h = normalize(l + e);
		NoH = max(dot(n, h), 0.0);
		diffuse = kd * NoL;
		specular = ks * pow(NoH, spec_pow);
	}

	return att * le * (diffuse + specular) + la; //ka * la;
}

float3 renderDirLight(float3 posWS, float3 albedo, float3 normal, cbDirectionalLight light)
{
	const float3 one = float3(1, 1, 1);
	const float3 amb = float3(0.01, 0.01, 0.02);
	
	float3 E = normalize(cs_camPos - posWS);
	float3 L = normalize(light.cDir); // check if inverted -- should be fine
	
	// float3 N = normal.xyz;
	// float3 kd = albedo.rgb;
	// float3 ks = light.spec.rgb;
	// float3 ks = float3(1, 1, 1);
	// const float3 ka = float3(1.0, 1.0, 1.0);
	// float3 la = light.ambient.rgb;
	// float3 le = light.diffuse.rgb;
	// float  sp = 30;
	// float  att = 1.0f;
	
	return blinn_phong(normal, L, E,
		   light.cColor, amb, 30, 
		   albedo, one, one, 1.0);	   
}

float3 renderPointLight(float3 posWS, float3 albedo, float3 normal, cbPointLight light)
{
	const float3 one = float3(1, 1, 1);
	const float3 zero = float3(0, 0, 0);
	
	float3 E = normalize(cs_camPos - posWS);
	float3 L = light.cPos - posWS;
	float  dist = length(L);
	float  att = getPointLightAtt(light.cRadius, dist);
	L = normalize(L);
	
	return blinn_phong(normal, L, E,
				   light.cColor, zero, light.cSpecPow, 
				   albedo, one, one, att);
}
/*
float getReflZ(int2 coord, float3 viewRay)
{
	float perspectiveZ = gDepthMap.Load(uint3(coord.xy, 0)).x;
	float linearZ = cs_projB / (perspectiveZ - cs_projA);
	float viewRayProjCamZ = dot(cs_camZAxis, viewRay);
	float3 posWS = cs_camPos + viewRay * (linearZ / viewRayProjCamZ);
	float3 v0 = mul(float4(posWS,1.0),gView).xyz;
	return v0.z;
}

float2 NormalizedDeviceCoordToScreenCoord(float2 ndc, float2 dim)
{
   float2 screenCoord;
   screenCoord.x = dim.x * ((ndc.x * 0.5)+0.5);
   screenCoord.y = dim.y * (1.0f - ((ndc.y * 0.5)+0.5));
   return screenCoord;
}
*/

float4 DeferredLightPass_Clustered_PS(COLORED_MINIMAL_MESH_PS_IN pIn)
{


	uint4 fragCoord = pIn.iPosH;

	float4 albedo = gDiffuseMap.Load(uint3(fragCoord.xy, 0));
	float4 normal = gAdditionalDiffuseMap.Load(uint3(fragCoord.xy, 0));
	float perspectiveZ = gDepthMap.Load(uint3(fragCoord.xy, 0)).x;
	
	float3 viewRay = normalize(pIn.viewRay);
	float linearZ = cs_projB / (perspectiveZ - cs_projA);
	
	float3 camZ = float3(gView[2][0], gView[2][1], gView[2][2]);
	float3 camPos = float3(gView[3][0], gView[3][1], gView[3][2]);
	float viewRayProjCamZ = dot(camZ, viewRay);
	//float viewRayProjCamZ = dot(cs_camZAxis, viewRay);
	//float3 posWS = cs_camPos + viewRay * (linearZ / viewRayProjCamZ);
	float3 posWS = camPos + viewRay * (linearZ / viewRayProjCamZ);
	
	/*
	//Liu
	
	//get screen dimension
	uint width;
	uint height;
	gDiffuseMap.GetDimensions(width, height);
	float2 dim = float2(width, height);

	//test coord
	float2 coord;

	//step counter;
	float t = 1;

	//get CS reflection ray
	float3 n = normal.xyz;
	float3 d = viewRay;
	float3 refl = normalize(reflect(d, n));
	float3 ScreenRefl = mul( refl, (float3x3)gView);

	//get reflactivity
	float reflectivity = posWS.y>0?0:0.5;

	float4 reflColor = float4(0, 0, 0, 0);

	//CS ray start & end point
	float3 v0 = mul(float4(posWS,1.0),gView).xyz;

	//float rayLength = ((csOrig.z + ScreenRefl.z * cs_far) > cs_near) ? (cs_near - csOrig.z) / ScreenRefl.z : cs_far;

	float3 v1 = v0 + ScreenRefl * cs_far;

	//NDCS  ray start & end point
	float4 p0 = mul( float4(v0,1.0), gViewProj );
	float4 p1 = mul( float4(v1,1.0), gViewProj );

	//projection factor
	float k0 = 1.0f / p0.w;
	float k1 = 1.0f / p1.w;

	p0 *= k0; 
	p1 *= k1;

	//get screen space coord
	p0.xy = NormalizedDeviceCoordToScreenCoord(p0.xy,dim);
	p1.xy = NormalizedDeviceCoordToScreenCoord(p1.xy,dim);

	v0 *= k0;
	v1 *= k1;


	float divisions = length(p1 - p0);
	float3 dV = (v1 - v0) / divisions;
	float dK = (k1 - k0) / divisions;
	float2 traceDir = (p1 - p0) / divisions;


	float maxSteps = min(MAX_STEPS, divisions);

	if (reflectivity > 0.0f)
	{
       while( t < maxSteps)
       {
			coord = fragCoord + traceDir * t;

			if(coord.x >= dim.x || coord.y >= dim.y || coord.x < 0 || coord.y < 0)
			{
				//reflColor = float4(gDiffuseMap.Load(uint3(fragCoord.xy, 0)).xyz,1.0);
				break;
			} 

			float curDepth = (v0 + dV * t).z;
			curDepth /= k0 + dK * t; // Reverse the perspective divide back to view space

			float storedDepth =  getReflZ(coord,viewRay);//getReflZ(coord,viewRay);//gWindMap.Load(uint3(coord.xy, 0)).z;

			if( curDepth > storedDepth && curDepth - storedDepth < MAX_INTERSECT_DIST)
			{
				reflColor = float4(gDiffuseMap.Load(uint3(coord.xy, 0)).xyz,1.0);
				break;
			}
			t++;
	   }
	}

	//end liu
	*/

	
	// Lighting 
	float3 finalColor = float3(0, 0, 0);
	
	// Process directional light first
	for (uint i = 0; i < cs_dirLightNum; i++)
	{
		finalColor += renderDirLight(posWS, albedo.xyz, normal.xyz, cs_dirLights[i]);
	}
	
	int4 cluster_coord = int4(posWS * cs_scale + cs_bias, 0);
	
	
	
	ClusterData data = gClusters.Load(cluster_coord);
	uint offset = data.offset;
	uint counts = data.counts;
	
	uint pointLightCount = counts >> 16;
	uint spotLightCount  = counts & 0xFFFF;
	
	//return float4(float(pointLightCount), float(pointLightCount), float(pointLightCount), 1);
	
	for (uint i = 0; i < pointLightCount; i++)
	{
		uint lightIndex = gLightIndices[offset + i];
		finalColor += renderPointLight(posWS, albedo.xyz, normal.xyz, cs_pointLights[lightIndex]);
	}
	
	return float4(finalColor.xyz,1.0);
	
	//return  float4(albedo.xyz,1.0); // * (1.0f - reflectivity)+ float4(reflColor.xyz,1.0) * reflectivity;
	
	
}

PS_wrapper_COLORED_MINIMAL_MESH(DeferredLightPass_Clustered_PS)

#endif
