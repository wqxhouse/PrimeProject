#ifndef DEFERRED_LIGHT_PASS_CLUSTERED_PS
#define DEFERRED_LIGHT_PASS_CLUSTERED_PS

#include "APIAbstraction.gpu"
#include "StandardConstants.fx"
#include "StandardTextureResources.fx"
#include "samplerhelper.fx"
#include "lighthelper.fx"
#include "ColoredMinimalMesh_Structs.fx"
#include "DeferredLightCommon.fx"

#include "LightUtils.fx"

#define MAX_STEPS 300
#define MAX_INTERSECT_DIST 0.04

float getPointLightAtt(float radius, float dist) 
{
    // Soft transition
    float attenuation = pow(1.0 + (dist / radius) , -2.0) * 1.2;
    
    float cutoff = radius * 0.7;
    attenuation *= 1.0 - smoothstep(0.0, 1.0, ( (dist / cutoff) - 1.0) * 4.0 );
    attenuation = max(0.0, attenuation);
    return attenuation;
}

float3 blinn_phong(float3 n, float3 l, float3 e, 
				   float3 le, float3 la, float spec_pow, 
				   float3 kd, float3 ks, float3 ka, float att)
{
	float NoH = 0.0f;
	float NoL = dot(n, l);
	float3 diffuse = float3(0, 0, 0);
	float3 specular = float3(0, 0, 0);
	if (NoL > 0)
	{
		float3 h = normalize(l + e);
		NoH = max(dot(n, h), 0.0);
		diffuse = kd * NoL;
		specular = ks * pow(NoH, spec_pow);
	}

	return att * le * (diffuse + specular) + la; //ka * la;
}

float3 renderDirLight(float3 posWS, float3 albedo, float3 normal, cbDirectionalLight light)
{
	const float3 one = float3(1, 1, 1);
	const float3 amb = float3(0.01, 0.01, 0.02);
	
	float3 camPos = float3(gView[3][0], gView[3][1], gView[3][2]);

	float3 E = normalize(camPos - posWS);
	float3 L = normalize(light.cDir); // check if inverted -- should be fine
	
	return blinn_phong(normal, L, E,
		   light.cColor, amb, 30, 
		   albedo, one, one, 1.0);	   
}

float3 renderPointLight(float3 posWS, float3 albedo, float3 normal, cbPointLight light)
{
	const float3 one = float3(1, 1, 1);
	const float3 zero = float3(0, 0, 0);
	
	float3 camPos = float3(gView[3][0], gView[3][1], gView[3][2]);
	
	//float3 E = normalize(cs_camPos - posWS);
	float3 E = normalize(camPos - posWS);
	float3 L = light.cPos - posWS;
	float  dist = length(L);
	float  att = getPointLightAtt(light.cRadius, dist);
	L = normalize(L);
	
	return blinn_phong(normal, L, E,
				   light.cColor, zero, light.cSpecPow, 
				   albedo, one, one, att);
}

float4 DeferredLightPass_Clustered_PS(COLORED_MINIMAL_MESH_PS_IN pIn)
{
	uint4 fragCoord = pIn.iPosH;

	float4 albedo = gDiffuseMap.Load(uint3(fragCoord.xy, 0));
	float4 normal = gAdditionalDiffuseMap.Load(uint3(fragCoord.xy, 0));
	float4 material = gWindMap.Load(uint3(fragCoord.xy, 0));
	float roughness = material.r;
	float metallic = material.g;
	
	float perspectiveZ = gDepthMap.Load(uint3(fragCoord.xy, 0)).x;
	
	float3 viewRay = normalize(pIn.viewRay);
	float linearZ = cs_projB / (perspectiveZ - cs_projA);
	
	float3 camZ = float3(gView[2][0], gView[2][1], gView[2][2]);
	float3 camPos = float3(gView[3][0], gView[3][1], gView[3][2]);
	float viewRayProjCamZ = dot(camZ, viewRay);
	//float viewRayProjCamZ = dot(cs_camZAxis, viewRay);
	//float3 posWS = cs_camPos + viewRay * (linearZ / viewRayProjCamZ);
	float3 posWS = camPos + viewRay * (linearZ / viewRayProjCamZ);
	
	// Lighting 
	float3 finalColor = float3(0, 0, 0);
	
	// Process directional light first
	for (uint dir = 0; dir < cs_dirLightNum; dir++)
	{
		cbDirectionalLight dirL = cs_dirLights[dir];
		// finalColor += renderDirLight(posWS, albedo.xyz, normal.xyz, cs_dirLights[dir]);
			
		finalColor += CalcDirectionalLight(normal.xyz, dirL.cDir, dirL.cColor, albedo.xyz, metallic, roughness, posWS, camPos);
	}
	
	int4 cluster_coord = int4(posWS * cs_scale + cs_bias, 0);
	
	ClusterData data = gClusters.Load(cluster_coord);
	uint offset = data.offset;
	uint counts = data.counts;
	
	uint pointLightCount = counts >> 16;
	uint spotLightCount  = counts & 0xFFFF;
	
	for (uint pt = 0; pt < pointLightCount; pt++)
	{
		uint lightIndex = gLightIndices[offset + pt];
		
		// finalColor += renderPointLight(posWS, albedo.xyz, normal.xyz, cs_pointLights[lightIndex]);
		
		Surface surf;
		surf.posWS = posWS;
		surf.normalWS = normal.xyz;
		surf.diffuse = albedo.xyz;
		surf.roughness = roughness;
		surf.metallic = metallic;
		finalColor += CalcPointLight(surf, cs_pointLights[lightIndex], camPos);	
	}

	// Apply IBL
	if (enableIndirectLighting > 0)
	{
		float3 viewWS = normalize(camPos - posWS);
		float3 reflectWS = reflect(-viewWS, normal.xyz);

		uint width, height, numMips;
		
		if(enableLocalCubemap > 0)
		{
			LocalSpecularCubemap.GetDimensions(0, width, height, numMips);
		}
		else
		{
			GlobalSpecularCubemap.GetDimensions(0, width, height, numMips);
		}

		const float SqrtRoughness = sqrt(roughness);
		// Compute the mip level, assuming the top level is a roughness of 0.01
		float mipLevel = saturate(SqrtRoughness - 0.01f) * (numMips - 1.0f);

		// Compute fresnel
		float viewAngle = saturate(dot(viewWS, normal.xyz));
		float2 AB = SpecularCubemapLookup.SampleLevel(gDiffuseMapSampler, float2(viewAngle, SqrtRoughness), 0.0f);
		float fresnel = metallic * AB.x + AB.y;
		fresnel *= saturate(metallic * 100.0f);

		if (enableLocalCubemap > 0)
		{
			finalColor += LocalSpecularCubemap.SampleLevel(gDiffuseMapSampler, reflectWS, mipLevel) * fresnel;
		}
		else
		{
			finalColor += GlobalSpecularCubemap.SampleLevel(gDiffuseMapSampler, reflectWS, mipLevel) * fresnel;
		}
	}
	
	
	return float4(finalColor.xyz,1.0);
}

PS_wrapper_COLORED_MINIMAL_MESH(DeferredLightPass_Clustered_PS)

#endif
