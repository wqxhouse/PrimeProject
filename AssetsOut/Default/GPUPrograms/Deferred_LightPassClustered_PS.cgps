#ifndef DEFERRED_LIGHT_PASS_CLUSTERED_PS
#define DEFERRED_LIGHT_PASS_CLUSTERED_PS

#include "APIAbstraction.gpu"
#include "StandardConstants.fx"
#include "StandardTextureResources.fx"
#include "samplerhelper.fx"
#include "lighthelper.fx"
#include "ColoredMinimalMesh_Structs.fx"

// We use b4 since API_BUFFER_INDEX is up to 3 in StandardConstants.fx
cbuffer cbClusteredShadingConsts : register(b4)
{
	float cs_near      : packoffset(c0.x);
    float cs_far       : packoffset(c0.y);
    float cs_projA     : packoffset(c0.z);
    float cs_projB     : packoffset(c0.w);     
	float3 cs_camPos   : packoffset(c1);
	float cs_pad	   : packoffset(c1.w);
	float3 cs_camZAxis : packoffset(c2);
	float cs_pad2	   : packoffset(c2.w);
};

// texture register maxed t70 used in animations
// StructuredBuffer<Light> gDeferredLights : register(t71);

float3 blinn_phong(float3 n, float3 l, float3 e, 
				   float3 le, float3 la, float spec_pow, 
				   float3 kd, float3 ks, float3 ka)
{
	float NoH = 0.0f;
	float NoL = dot(n, l);
	if (NoL > 0)
	{
		float3 h = normalize(l + e);
		NoH = max(dot(n, h), 0.0);
	}

	return le * (kd * NoL + ks * pow(NoH, spec_pow)) + la; //ka * la;
}

float4 DeferredLightPass_Clustered_PS(COLORED_MINIMAL_MESH_PS_IN pIn)
{
	uint4 fragCoord = pIn.iPosH;

	float4 albedo = gDiffuseMap.Load(uint3(fragCoord.xy, 0));
	float4 normal = gAdditionalDiffuseMap.Load(uint3(fragCoord.xy, 0));
	float perspectiveZ = gDepthMap.Load(uint3(fragCoord.xy, 0)).x;
	
	float3 viewRay = normalize(pIn.viewRay);
	float linearZ = cs_projB / (perspectiveZ - cs_projA);
	
	float viewRayProjCamZ = dot(cs_camZAxis, viewRay);
	float3 posWS = cs_camPos + viewRay * (linearZ / viewRayProjCamZ);
	
	// Lighting 
	Light light = gLight0;
	
	float3 E = normalize(cs_camPos - posWS);
	float3 L = normalize(light.xyzDir_w.xyz);
	float3 N = normal.xyz;
	float3 kd = albedo.rgb;
	float3 ks = light.spec.rgb;
	const float3 ka = float3(1.0, 1.0, 1.0);
	float3 la = light.ambient.rgb;
	float3 le = light.diffuse.rgb;
	float  sp = light.xyzAtt_wSpotPwr.w; // hardcode for now
	
	float3 color = blinn_phong(N, L, E,
				   le, la, sp, 
				   kd, ks, ka);
				   
	return float4(color, 1.0);
	
	
	// float3 quadPosWS = pIn.iQuadPosW; 
	// float3 viewRay = quadPosWS - cs_camPos;
    // float3 viewRay = float3(quadPos.xy  / quadPos.z, 1.0f);
	
	//float3 viewRay = pIn.viewRay;
    //float3 posWS = cs_camPos + linearZ * viewRay;
	
	//float3 normViewRay = normalize(viewRay);
	//float linZ = linearZ * cs_far;
	//float3 posWS = cs_camPos + normViewRay * linZ;
	
	//float3 posVS = mul(posWS, gView);
	
	// float3 viewRay = float3(quadVSPos.xy * (cs_far / quadVSPos.z), cs_far);
	// float3 posVS = viewRay * (linearZ * cs_far);
	
	
	// return float4(1.0, 1.0, 0.8 ,1.0);
	// return float4(posWS, 1.0);
	// return float4(linearZ, linearZ, linearZ, 1.0);
	// return float4(perspectiveZ, perspectiveZ, perspectiveZ, 1.0);
	// return float4(0.3, 0.7, 0.3, 1.0);
	 //return normal;
}

PS_wrapper_COLORED_MINIMAL_MESH(DeferredLightPass_Clustered_PS)

#endif
